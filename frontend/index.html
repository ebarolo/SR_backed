<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ricette – Ricerca</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    // Palette/Theme (One UI-like: soft, arioso, focus su contenuto)
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            brand: {
              50:  '#eef6ff',
              100: '#d9ebff',
              200: '#b7d7ff',
              300: '#8fbfff',
              400: '#5b9bff',
              500: '#2a73ff',  // accento
              600: '#1f5be0',
              700: '#1a4cbc',
              800: '#173f9a',
              900: '#132f72',
            }
          },
          boxShadow: {
            card: '0 6px 18px rgba(0,0,0,.08), 0 2px 6px rgba(0,0,0,.05)',
            cardHover: '0 16px 32px rgba(0,0,0,.14), 0 4px 12px rgba(0,0,0,.08)'
          }
        }
      }
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/node-vibrant/dist/vibrant.min.js"></script>

  <style>
    /* Utility per masonry: evita il break dentro le card */
    .avoid-break { break-inside: avoid; }
    /* Clamp descrizione (senza plugin) */
    .clamp-3 {
      display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden;
    }
    /* Smooth hover */
    .smooth { transition: all .25s ease; }
  </style>
</head>
<body class="bg-neutral-50 text-neutral-900 antialiased">
  <!-- App Bar -->
  <header class="sticky top-0 z-30 backdrop-blur bg-white/70 border-b border-neutral-200">
    <div class="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8 py-4 flex items-center gap-4">
      <div class="flex items-center gap-3">
        <div class="h-10 w-10 rounded-2xl bg-brand-500 flex items-center justify-center text-white font-semibold">R</div>
        <div>
          <h1 class="text-xl font-semibold tracking-tight">Cerca ricette</h1>
          <p class="text-sm text-neutral-500"> Ricerca semantica + filtri smart</p>
        </div>
      </div>

    </div>
  </header>

  <!-- Search + NLP chips -->
  <section class="mx-auto max-w-4xl px-4 sm:px-6 lg:px-8 py-6">
    <div class="rounded-3xl shadow-card bg-white p-4 sm:p-5 smooth">
      <div class="flex items-center gap-3">
        <div class="hidden sm:flex h-11 w-11 rounded-2xl bg-brand-50 text-brand-700 items-center justify-center">🔎</div>
        <div class="flex-1">
          <label for="q" class="sr-only">Cerca</label>
          <input id="q" type="text" autocomplete="off"
            placeholder="Es. pasta al pomodoro veloce senza glutine <30 min, dolci freddi, zuppa vegana con ceci…"
            class="w-full h-12 sm:h-14 px-4 sm:px-6 rounded-2xl bg-neutral-50 border border-neutral-200 focus:border-brand-400 focus:ring-4 focus:ring-brand-100 outline-none text-base sm:text-lg smooth" />
        </div>
        <button id="btnSearch"
          class="h-12 sm:h-14 px-5 rounded-2xl bg-brand-500 text-white text-sm sm:text-base font-medium hover:bg-brand-600 smooth">
          Cerca
        </button>
      </div>

      <!-- Chips NLP -->
      <div id="chips" class="mt-4 flex flex-wrap gap-2"></div>

      <!-- Sottosuggerimenti -->
      <div class="mt-3 text-sm text-neutral-500">
        Suggerimenti: 
        <button class="underline hover:text-neutral-700 smooth"
          onclick="preset('primi veloci <20 senza lattosio')">primi veloci &lt;20</button> ·
        <button class="underline hover:text-neutral-700 smooth"
          onclick="preset('dolce senza cottura con fragole')">dolce senza cottura</button> ·
        <button class="underline hover:text-neutral-700 smooth"
          onclick="preset('zuppa vegana con ceci <40')">zuppa vegana con ceci</button>
      </div>
    </div>
  </section>

  <!-- Results -->
  <main class="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8 pb-16">
    <div id="stats" class="mb-4 text-sm text-neutral-500"></div>

    <!-- Masonry Grid -->
    <div id="grid" class="columns-1 sm:columns-2 lg:columns-3 gap-6"></div>

    <!-- Empty state -->
    <div id="empty" class="hidden rounded-3xl border border-dashed border-neutral-300 p-10 text-center bg-white">
      <div class="mx-auto w-16 h-16 rounded-2xl bg-neutral-100 flex items-center justify-center text-2xl">🥄</div>
      <h3 class="mt-4 text-lg font-semibold">Nessun risultato</h3>
      <p class="mt-1 text-neutral-500">Prova a rimuovere qualche filtro o usa termini più generici.</p>
    </div>
  </main>

  <script>
    // ===========================
    // CONFIGURAZIONE API
    // ===========================
    const API_BASE_URL = window.location.origin;
    const SEARCH_ENDPOINT = '/search/';
    
    // Stato dell'applicazione
    let ricette = [];
    let isLoading = false;
    
    // Dati di fallback per quando l'API non è disponibile
    const FALLBACK_RICETTE = [
    
    ];

    // ===========================
    // NLP-LIKE PARSER (semplice)
    // ===========================
    const CATEGORIE = ['Antipasto','Primo','Secondo','Contorno','Dolce','Piatto unico','Zuppa','Colazione','Bevanda'];
    const MAP_CATEG = {
      'antipasto':'Antipasto','antipasti':'Antipasto',
      'primo':'Primo','primi':'Primo','pasta':'Primo','risotto':'Primo',
      'secondo':'Secondo','secondi':'Secondo','carne':'Secondo','pesce':'Secondo',
      'contorno':'Contorno','contorni':'Contorno',
      'dolce':'Dolce','dolci':'Dolce','dessert':'Dolce',
      'piatto unico':'Piatto unico','unico':'Piatto unico',
      'zuppa':'Zuppa','minestra':'Zuppa','vellutata':'Zuppa',
      'colazione':'Colazione','breakfast':'Colazione',
      'bevanda':'Bevanda','drink':'Bevanda'
    };

    const TIPI = ['vegano','vegetariano','senza glutine','light','pesce','carne','senza lattosio'];
    const NORMALIZE = s => s.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'');

    function parseQuery(q) {
      const raw = NORMALIZE(q);
      const tokens = raw.split(/[\s,]+/).filter(Boolean);

      const includeWords = [];
      const excludeWords = [];
      const categorie = new Set();
      const tipologie = new Set();
      let maxMinuti = null;

      // pattern tempo: "<30", "<=20", "20m", "20min", "20 minuti", "meno di 30"
      const ltNum = raw.match(/<\s*(\d{1,3})/);
      if (ltNum) maxMinuti = parseInt(ltNum[1],10);
      const numMin = raw.match(/(\d{1,3})\s*(m|min|minuti)\b/);
      if (!maxMinuti && numMin) maxMinuti = parseInt(numMin[1],10);
      const menoDi = raw.match(/meno\s+di\s+(\d{1,3})/);
      if (!maxMinuti && menoDi) maxMinuti = parseInt(menoDi[1],10);

      // categorie / tipologie
      Object.keys(MAP_CATEG).forEach(k=>{
        if (raw.includes(k)) categorie.add(MAP_CATEG[k]);
      });
      TIPI.forEach(t=>{
        if (raw.includes(t)) tipologie.add(t);
      });

      // senza X (esclusioni)
      const senzaMatches = [...raw.matchAll(/senza\s+([a-zàèéìòù\-]+)/g)];
      senzaMatches.forEach(m=> excludeWords.push(m[1]));

      // con X (inclusioni semplici)
      const conMatches = [...raw.matchAll(/\bcon\s+([a-zàèéìòù\-]+)/g)];
      conMatches.forEach(m=> includeWords.push(m[1]));

      // fallback: parole libere significative (>3 chars)
      if (includeWords.length === 0) {
        tokens.forEach(t=>{
          if (t.length>3 && !['meno','di','con','senza','che','per','una','alle','alla','gli','del','dei','delle'].includes(t)) {
            includeWords.push(t);
          }
        });
      }

      return {
        maxMinuti,
        categorie: [...categorie],
        tipologie: [...tipologie],
        include: [...new Set(includeWords)],
        exclude: [...new Set(excludeWords)],
      };
    }

    function matchRicetta(r, query) {
      const hay = NORMALIZE([r.titolo, r.descrizione, r.categoria, r.tipologia?.join(' '), r.ingredienti?.join(' ')].join(' '));
      // tempo
      if (query.maxMinuti!=null && (r.tempoCottura ?? 999) > query.maxMinuti) return false;
      // categorie (se presenti -> OR)
      if (query.categorie.length>0 && !query.categorie.includes(r.categoria)) return false;
      // tipologie (tutte devono comparire)
      for (const t of query.tipologie) {
        const ok = (r.tipologia||[]).some(rt => NORMALIZE(rt) === t);
        if (!ok) return false;
      }
      // include (tutte devono comparire)
      for (const inc of query.include) {
        if (!hay.includes(NORMALIZE(inc))) return false;
      }
      // exclude (nessuna deve comparire)
      for (const exc of query.exclude) {
        if (hay.includes(NORMALIZE(exc))) return false;
      }
      return true;
    }

    // ===========================
    // API FUNCTIONS
    // ===========================
    async function searchRecipes(query, filters = {}) {
      if (isLoading) return;
      
      isLoading = true;
      showLoadingState();
      
      try {
        const params = new URLSearchParams({
          query: query,
          limit: 20,
          ...filters
        });
        
        const response = await fetch(`${API_BASE_URL}${SEARCH_ENDPOINT}?${params}`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
          }
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        // Converte i dati dell'API nel formato atteso dal frontend
        const formattedRecipes = data.map(recipe => ({
          id: recipe.shortcode || recipe.id,
          titolo: recipe.title || recipe.titolo,
          descrizione: recipe.description || recipe.descrizione || '',
          immagine: recipe.image_url || recipe.immagine || '/static/mediaRicette/default.jpg',
          categoria: recipe.category || recipe.categoria || 'Generale',
          tempoCottura: recipe.cooking_time || recipe.tempoCottura || 0,
          tipologia: recipe.dietary_tags || recipe.tipologia || [],
          ingredienti: recipe.ingredients || recipe.ingredienti || []
        }));
        
        ricette = formattedRecipes;
        hideLoadingState();
        return formattedRecipes;
        
      } catch (error) {
        console.error('Errore nella ricerca API:', error);
        // Fallback ai dati statici in caso di errore
        ricette = FALLBACK_RICETTE;
        hideLoadingState();
        showErrorMessage('Errore di connessione. Mostro ricette di esempio.');
        return FALLBACK_RICETTE;
      } finally {
        isLoading = false;
      }
    }
    
    function showLoadingState() {
      const grid = document.getElementById('grid');
      grid.innerHTML = `
        <div class="col-span-full flex items-center justify-center py-12">
          <div class="text-center">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-brand-500 mx-auto"></div>
            <p class="mt-4 text-neutral-600">Ricerca in corso...</p>
          </div>
        </div>
      `;
    }
    
    function hideLoadingState() {
      // Il loading state viene sostituito dal render dei risultati
    }
    
    function showErrorMessage(message) {
      const grid = document.getElementById('grid');
      grid.innerHTML = `
        <div class="col-span-full flex items-center justify-center py-12">
          <div class="text-center">
            <div class="w-16 h-16 rounded-2xl bg-red-100 flex items-center justify-center text-2xl mx-auto">⚠️</div>
            <h3 class="mt-4 text-lg font-semibold text-red-800">Errore</h3>
            <p class="mt-1 text-red-600">${message}</p>
          </div>
        </div>
      `;
    }

    // ===========================
    // RENDER
    // ===========================
    const grid = document.getElementById('grid');
    const empty = document.getElementById('empty');
    const stats = document.getElementById('stats');
    const chips = document.getElementById('chips');
    const input = document.getElementById('q');

    let currentFilters = parseQuery('');

    function render(recList){
      grid.innerHTML = '';
      if (recList.length === 0) {
        empty.classList.remove('hidden');
        stats.textContent = '0 ricette';
        return;
      }
      empty.classList.add('hidden');
      stats.textContent = `${recList.length} ricette`;

      recList.forEach(r=>{
        const card = document.createElement('article');
        card.className = 'avoid-break mb-6 smooth';
        card.innerHTML = `
          <div class="group rounded-3xl bg-white shadow-card hover:shadow-cardHover smooth overflow-hidden border border-neutral-100 card-skin">
            <div class="relative">
              <img loading="lazy" crossorigin="anonymous" src="${r.immagine}" alt="${r.titolo}" class="w-full object-cover max-h-[300px] sm:max-h-[360px] group-hover:scale-[1.02] smooth" onerror="this.style.display='none'; this.parentElement.querySelector('.img-fallback').classList.remove('hidden')" />
              <div class="img-fallback hidden w-full h-48 bg-gradient-to-br from-brand-50 to-neutral-100"></div>

              <!-- Badge tempo -->
              <div class="absolute top-3 left-3">
                <span class="px-3 py-1 rounded-full text-xs font-medium bg-black/60 text-white backdrop-blur">
                  ⏱️ ${r.tempoCottura} min
                </span>
              </div>
              <!-- Badge categoria -->
              <div class="absolute top-3 right-3">
                <span class="px-3 py-1 rounded-full text-xs font-medium bg-white/90 text-neutral-800 border border-neutral-200">
                  ${r.categoria}
                </span>
              </div>
            </div>

            <div class="p-4 sm:p-5">
              <h3 class="text-lg sm:text-xl font-semibold tracking-tight">${r.titolo}</h3>
              <p class="mt-2 text-sm text-neutral-600 clamp-3">${r.descrizione}</p>

              <div class="mt-4 flex flex-wrap gap-2">
                ${(r.tipologia||[]).map(t=>`<span class="px-2.5 py-1 rounded-full text-xs bg-brand-50 text-brand-700 border border-brand-100">${t}</span>`).join('')}
                ${(r.ingredienti||[]).slice(0,4).map(i=>`<span class="px-2.5 py-1 rounded-full text-xs bg-neutral-100 text-neutral-700">${i}</span>`).join('')}
              </div>

              <div class="mt-4 flex items-center justify-between">
                <button class="px-3 py-2 rounded-xl bg-neutral-100 hover:bg-neutral-200 text-sm smooth">Dettagli</button>
                <button class="px-3 py-2 rounded-xl bg-brand-500 text-white hover:bg-brand-600 text-sm smooth">Aggiungi ai preferiti</button>
              </div>
            </div>
          </div>
        `;
        grid.appendChild(card);
        const img = card.querySelector('img');
        const skin = card.querySelector('.card-skin');
        if (img && skin) {
          if (img.complete) setCardTint(img, skin);
          else img.addEventListener('load', () => setCardTint(img, skin), { once: true });
        }
      });
    }

    function renderChips(q) {
      chips.innerHTML = '';
      const make = (label, onRemove) => {
        const el = document.createElement('button');
        el.className = 'group px-3 py-1.5 rounded-full bg-neutral-100 hover:bg-neutral-200 text-sm smooth border border-neutral-200';
        el.innerHTML = `${label} <span class="ml-1 text-neutral-500 group-hover:text-neutral-700">✕</span>`;
        el.onclick = onRemove;
        chips.appendChild(el);
      };
      if (q.maxMinuti!=null) make(`<${q.maxMinuti} min`, async ()=>{ currentFilters.maxMinuti=null; await apply(); });
      q.categorie.forEach(c=> make(c, async ()=>{ currentFilters.categorie = q.categorie.filter(x=>x!==c); await apply(); }));
      q.tipologie.forEach(t=> make(t, async ()=>{ currentFilters.tipologie = q.tipologie.filter(x=>x!==t); await apply(); }));
      q.include.forEach(k=> make(`include:${k}`, async ()=>{ currentFilters.include = q.include.filter(x=>x!==k); await apply(); }));
      q.exclude.forEach(k=> make(`senza:${k}`, async ()=>{ currentFilters.exclude = q.exclude.filter(x=>x!==k); await apply(); }));
    }

    async function apply() {
      renderChips(currentFilters);
      
      // Costruisci la query di ricerca combinando tutti i filtri
      const searchQuery = buildSearchQuery(currentFilters);
      
      // Costruisci i filtri per l'API
      const apiFilters = buildApiFilters(currentFilters);
      
      // Esegui la ricerca tramite API
      const results = await searchRecipes(searchQuery, apiFilters);
      
      // Applica filtri locali se necessario (per compatibilità)
      const filteredResults = results.filter(r => matchRicetta(r, currentFilters));
      render(filteredResults);
    }
    
    function buildSearchQuery(filters) {
      const parts = [];
      
      // Aggiungi parole di inclusione
      if (filters.include.length > 0) {
        parts.push(filters.include.join(' '));
      }
      
      // Aggiungi categorie
      if (filters.categorie.length > 0) {
        parts.push(filters.categorie.join(' '));
      }
      
      // Aggiungi tipologie
      if (filters.tipologie.length > 0) {
        parts.push(filters.tipologie.join(' '));
      }
      
      // Se non ci sono filtri specifici, usa una query generica
      if (parts.length === 0) {
        return 'ricette';
      }
      
      return parts.join(' ');
    }
    
    function buildApiFilters(filters) {
      const apiFilters = {};
      
      // Filtro per tempo massimo
      if (filters.maxMinuti !== null) {
        apiFilters.max_time = filters.maxMinuti;
      }
      
      // Filtro per dieta (mappatura tipologie -> diet)
      const dietMapping = {
        'vegano': 'vegan',
        'vegetariano': 'vegetarian',
        'senza glutine': 'gluten-free',
        'light': 'light'
      };
      
      const dietFilters = filters.tipologie
        .map(t => dietMapping[t])
        .filter(Boolean);
      
      if (dietFilters.length > 0) {
        apiFilters.diet = dietFilters[0]; // L'API accetta una sola dieta
      }
      
      return apiFilters;
    }

    function setCardTint(img, skinEl) {
      if (!window.Vibrant || !img || !skinEl) return;
      
      // Fallback: colori predefiniti per evitare errori CORS
      const fallbackColors = [
        'rgba(42, 115, 255, 0.14)', // brand-500
        'rgba(139, 191, 255, 0.14)', // brand-300  
        'rgba(91, 155, 255, 0.14)', // brand-400
        'rgba(183, 215, 255, 0.14)', // brand-200
      ];
      const randomFallback = fallbackColors[Math.floor(Math.random() * fallbackColors.length)];
      
      try {
        // Controlla se l'immagine è accessibile (stesso dominio o CORS abilitato)
        if (img.crossOrigin !== 'anonymous' && !img.src.startsWith(window.location.origin)) {
          // Usa fallback per immagini cross-origin senza CORS
          skinEl.style.background = `linear-gradient(180deg, ${randomFallback}, rgba(42, 115, 255, 0.05))`;
          skinEl.style.borderColor = `rgba(42, 115, 255, 0.25)`;
          return;
        }

        Vibrant.from(img).getPalette().then(p => {
          const sw = p.Vibrant || p.Muted || p.LightVibrant || p.DarkMuted;
          if (!sw) {
            // Fallback se non vengono estratti colori
            skinEl.style.background = `linear-gradient(180deg, ${randomFallback}, rgba(42, 115, 255, 0.05))`;
            skinEl.style.borderColor = `rgba(42, 115, 255, 0.25)`;
            return;
          }
          const rgb = sw.rgb.map(x=>Math.round(x));
          const r=rgb[0], g=rgb[1], b=rgb[2];
          skinEl.style.background = `linear-gradient(180deg, rgba(${r},${g},${b},0.14), rgba(${r},${g},${b},0.05))`;
          skinEl.style.borderColor = `rgba(${r},${g},${b},0.25)`;
        }).catch(err => {
          // Gestisce errori CORS e altri errori di Vibrant
          console.warn('Vibrant color extraction failed (probabilmente CORS):', err.message);
          skinEl.style.background = `linear-gradient(180deg, ${randomFallback}, rgba(42, 115, 255, 0.05))`;
          skinEl.style.borderColor = `rgba(42, 115, 255, 0.25)`;
        });
      } catch(e) { 
        // Fallback finale per qualsiasi errore
        console.warn('setCardTint error:', e.message);
        skinEl.style.background = `linear-gradient(180deg, ${randomFallback}, rgba(42, 115, 255, 0.05))`;
        skinEl.style.borderColor = `rgba(42, 115, 255, 0.25)`;
      }
    }
    // ===========================
    // INTERAZIONE
    // ===========================
    async function searchNow() {
      currentFilters = parseQuery(input.value.trim());
      await apply();
    }
    document.getElementById('btnSearch').addEventListener('click', searchNow);
    document.getElementById('btnClear').addEventListener('click', async ()=>{
      input.value = '';
      currentFilters = parseQuery('');
      await apply();
    });
    document.getElementById('btnRandom').addEventListener('click', async ()=>{
      const samples = [
        'primo veloce <20 con pomodoro',
        'dolce senza cottura con fragole',
        'zuppa vegana con ceci <40',
        'secondo di pesce <30',
        'senza glutine con quinoa <20'
      ];
      const s = samples[Math.floor(Math.random()*samples.length)];
      input.value = s;
      currentFilters = parseQuery(s);
      await apply();
    });
    input.addEventListener('keydown', (e)=>{ if(e.key==='Enter') searchNow(); });

    // helper per suggerimenti
    window.preset = (q)=>{ input.value=q; searchNow(); };

    // Inizializzazione: carica ricette all'avvio
    async function initializeApp() {
      // Carica ricette iniziali con una query generica
      await searchRecipes('ricette', {});
      render(ricette);
    }

    // Avvia l'applicazione
    initializeApp();
  </script>
</body>
</html>
